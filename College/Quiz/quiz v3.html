<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Quiz/Exam Platform - Python Code Showcase</title>
    <link rel="icon" href="https://raw.githubusercontent.com/Runarok/GenAI-plus/main/GenAI-plus.png" type="image/png">
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #e0e0e0;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, #2d1b69 0%, #11998e 100%);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #a8edea);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .tech-stack {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .tech-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .nav-menu {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nav-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .nav-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 8px;
            text-decoration: none;
            color: white;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .section h2 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3 {
            color: #81c784;
            margin: 25px 0 15px 0;
            font-size: 1.4rem;
        }

        .description {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #4fc3f7;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-card {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .feature-card h4 {
            color: #ffeb3b;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .code-container {
            position: relative;
            margin: 20px 0;
        }

        .code-header {
            background: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: between;
            align-items: center;
            border-bottom: 1px solid #444;
        }

        .code-title {
            color: #4fc3f7;
            font-weight: bold;
        }

        .copy-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: auto;
        }

        .copy-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .copy-btn.copied {
            background: #2196f3;
        }

        pre {
            margin: 0 !important;
            border-radius: 0 0 8px 8px !important;
            max-height: 500px;
            overflow-y: auto;
        }

        .usage-example {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4caf50;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .usage-example h4 {
            color: #4caf50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .complexity-info {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .complexity-info h5 {
            color: #ffc107;
            margin-bottom: 8px;
        }

        .data-structures {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .ds-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ds-card h4 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .algorithms {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .algo-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 25px;
            border-radius: 12px;
            color: white;
        }

        .algo-card h4 {
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .scrollspy-nav {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .scrollspy-nav a {
            display: block;
            color: #ccc;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 5px;
            margin: 5px 0;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .scrollspy-nav a:hover,
        .scrollspy-nav a.active {
            background: #4fc3f7;
            color: white;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .scrollspy-nav {
                display: none;
            }
            
            .nav-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 2000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1><i class="fas fa-graduation-cap"></i> Online Quiz/Exam Platform</h1>
            <p>Comprehensive Python Implementation with OOP, DSA & Algorithms</p>
            <div class="tech-stack">
                <span class="tech-badge"><i class="fab fa-python"></i> Python OOP</span>
                <span class="tech-badge"><i class="fas fa-link"></i> Linked Lists</span>
                <span class="tech-badge"><i class="fas fa-hashtag"></i> Hash Maps</span>
                <span class="tech-badge"><i class="fas fa-layer-group"></i> Queues</span>
                <span class="tech-badge"><i class="fas fa-calculator"></i> Algorithms</span>
            </div>
        </header>

        <nav class="nav-menu">
            <div class="nav-grid">
                <a href="#question-class" class="nav-item">
                    <i class="fas fa-question-circle"></i> Question Class
                </a>
                <a href="#quiz-class" class="nav-item">
                    <i class="fas fa-clipboard-list"></i> Quiz Class
                </a>
                <a href="#result-class" class="nav-item">
                    <i class="fas fa-chart-bar"></i> Quiz Result Class
                </a>
                <a href="#linked-list" class="nav-item">
                    <i class="fas fa-link"></i> Question Linked List
                </a>
                <a href="#hashmap" class="nav-item">
                    <i class="fas fa-hashtag"></i> User Score HashMap
                </a>
                <a href="#queue" class="nav-item">
                    <i class="fas fa-layer-group"></i> Exam Flow Queue
                </a>
                <a href="#algorithms" class="nav-item">
                    <i class="fas fa-calculator"></i> Scoring Algorithms
                </a>
                <a href="#generation" class="nav-item">
                    <i class="fas fa-random"></i> Question Generation
                </a>
            </div>
        </nav>

        <!-- Question Class Section -->
        <section id="question-class" class="section">
            <h2><i class="fas fa-question-circle"></i> Question Class</h2>
            
            <div class="description">
                <p>The <strong>Question</strong> class is the foundation of the quiz system. It represents individual questions with support for multiple question types, difficulty levels, and advanced features like similarity checking and statistics tracking.</p>
            </div>

            <div class="features">
                <div class="feature-card">
                    <h4><i class="fas fa-list"></i> Question Types</h4>
                    <p>Supports multiple choice, true/false, and short answer questions with flexible answer checking.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-signal"></i> Difficulty Levels</h4>
                    <p>5-level difficulty system (1-5) with automatic point multipliers for scoring.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-chart-line"></i> Statistics Tracking</h4>
                    <p>Tracks usage count, success rate, and performance metrics for adaptive learning.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-search"></i> Smart Answer Checking</h4>
                    <p>Advanced text similarity for short answers with configurable thresholds.</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">Question Class Implementation</span>
                    <button class="copy-btn" onclick="copyCode('question-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="question-code" class="language-python">class Question:
    def __init__(self, question_id, text, question_type, difficulty_level):
        self.question_id = question_id
        self.text = text
        self.question_type = question_type  # 'multiple_choice', 'true_false', 'short_answer'
        self.difficulty_level = difficulty_level  # 1-5 (1=easy, 5=hard)
        self.options = []  # For multiple choice questions
        self.correct_answer = None
        self.explanation = ""
        self.points = 1
        self.category = ""
        self.tags = []
        self.created_at = datetime.now()
        self.usage_count = 0
        self.success_rate = 0.0
    
    def add_option(self, option_text, is_correct=False):
        """Add option for multiple choice questions"""
        option = {
            'text': option_text,
            'is_correct': is_correct,
            'option_id': len(self.options)
        }
        self.options.append(option)
        
        if is_correct:
            self.correct_answer = option['option_id']
    
    def check_answer(self, user_answer):
        """Check if user answer is correct"""
        if self.question_type == 'multiple_choice':
            return user_answer == self.correct_answer
        elif self.question_type == 'true_false':
            return user_answer == self.correct_answer
        elif self.question_type == 'short_answer':
            return self.check_short_answer(user_answer)
        return False
    
    def check_short_answer(self, user_answer):
        """Check short answer with some flexibility"""
        if not self.correct_answer:
            return False
        
        user_lower = user_answer.lower().strip()
        correct_lower = self.correct_answer.lower().strip()
        
        # Exact match
        if user_lower == correct_lower:
            return True
        
        # Check for common variations
        similarity = self.calculate_similarity(user_lower, correct_lower)
        return similarity > 0.8  # 80% similarity threshold
    
    def update_statistics(self, was_correct):
        """Update question usage statistics"""
        self.usage_count += 1
        
        # Update success rate using moving average
        if self.usage_count == 1:
            self.success_rate = 1.0 if was_correct else 0.0
        else:
            # Weighted average favoring recent attempts
            weight = 0.1
            self.success_rate = (1 - weight) * self.success_rate + weight * (1.0 if was_correct else 0.0)
    
    def get_difficulty_multiplier(self):
        """Get point multiplier based on difficulty"""
        multipliers = {1: 1.0, 2: 1.2, 3: 1.5, 4: 1.8, 5: 2.0}
        return multipliers.get(self.difficulty_level, 1.0)</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Usage Example</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Creating and Using Questions</span>
                        <button class="copy-btn" onclick="copyCode('question-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="question-usage" class="language-python"># Create a multiple choice question
question = Question(1, "What is the capital of France?", "multiple_choice", 2)
question.add_option("London", False)
question.add_option("Berlin", False)
question.add_option("Paris", True)
question.add_option("Madrid", False)
question.explanation = "Paris is the capital and largest city of France."
question.category = "Geography"

# Check user answer
user_answer = 2  # Paris
is_correct = question.check_answer(user_answer)
print(f"Answer correct: {is_correct}")

# Create a short answer question
short_q = Question(2, "What is 2 + 2?", "short_answer", 1)
short_q.correct_answer = "4"
print(f"Answer '4' correct: {short_q.check_answer('4')}")
print(f"Answer 'four' correct: {short_q.check_answer('four')}")

# Update statistics
question.update_statistics(True)
print(f"Success rate: {question.success_rate}")
print(f"Difficulty multiplier: {question.get_difficulty_multiplier()}")</code></pre>
                </div>
            </div>

            <div class="complexity-info">
                <h5><i class="fas fa-clock"></i> Time Complexity Analysis</h5>
                <ul>
                    <li><strong>add_option():</strong> O(1) - Constant time insertion</li>
                    <li><strong>check_answer():</strong> O(1) for multiple choice, O(n) for short answer similarity</li>
                    <li><strong>update_statistics():</strong> O(1) - Simple arithmetic operations</li>
                </ul>
            </div>
        </section>

        <!-- Quiz Class Section -->
        <section id="quiz-class" class="section">
            <h2><i class="fas fa-clipboard-list"></i> Quiz Class</h2>
            
            <div class="description">
                <p>The <strong>Quiz</strong> class manages collections of questions and provides comprehensive quiz functionality including scoring, time limits, shuffling, and publishing controls.</p>
            </div>

            <div class="features">
                <div class="feature-card">
                    <h4><i class="fas fa-cogs"></i> Quiz Configuration</h4>
                    <p>Configurable time limits, attempt limits, passing scores, and question/option shuffling.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-calculator"></i> Advanced Scoring</h4>
                    <p>Multiple scoring methods with difficulty-based point multipliers and detailed analytics.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-certificate"></i> Certification</h4>
                    <p>Automatic certificate generation for passed quizzes with unique certificate IDs.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-eye"></i> Publishing Control</h4>
                    <p>Quiz publishing system with validation and access control mechanisms.</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">Quiz Class Implementation</span>
                    <button class="copy-btn" onclick="copyCode('quiz-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="quiz-code" class="language-python">class Quiz:
    def __init__(self, quiz_id, title, description, creator_id):
        self.quiz_id = quiz_id
        self.title = title
        self.description = description
        self.creator_id = creator_id
        self.questions = QuestionLinkedList()
        self.time_limit = None  # in minutes
        self.max_attempts = 1
        self.passing_score = 70  # percentage
        self.shuffle_questions = False
        self.shuffle_options = False
        self.is_published = False
        self.created_at = datetime.now()
        self.last_modified = datetime.now()
        self.total_points = 0
        self.category = ""
        self.difficulty_level = "medium"
    
    def add_question(self, question):
        """Add question to quiz"""
        self.questions.append(question)
        self.total_points += question.points * question.get_difficulty_multiplier()
        self.last_modified = datetime.now()
    
    def remove_question(self, question_id):
        """Remove question from quiz"""
        removed_question = self.questions.remove_by_id(question_id)
        if removed_question:
            self.total_points -= removed_question.points * removed_question.get_difficulty_multiplier()
            self.last_modified = datetime.now()
            return True
        return False
    
    def calculate_score(self, user_answers):
        """Calculate quiz score based on user answers"""
        total_points = 0
        earned_points = 0
        correct_count = 0
        total_count = 0
        
        questions = self.questions.to_list()
        
        for i, question in enumerate(questions):
            total_count += 1
            question_points = question.points * question.get_difficulty_multiplier()
            total_points += question_points
            
            if i < len(user_answers):
                user_answer = user_answers[i]
                if question.check_answer(user_answer):
                    earned_points += question_points
                    correct_count += 1
                    question.update_statistics(True)
                else:
                    question.update_statistics(False)
        
        percentage = (earned_points / total_points * 100) if total_points > 0 else 0
        
        return {
            'earned_points': earned_points,
            'total_points': total_points,
            'percentage': percentage,
            'correct_count': correct_count,
            'total_count': total_count,
            'passed': percentage >= self.passing_score
        }
    
    def generate_certificate_data(self, user_id, score_data):
        """Generate data for completion certificate"""
        return {
            'user_id': user_id,
            'quiz_title': self.title,
            'score_percentage': score_data['percentage'],
            'points_earned': score_data['earned_points'],
            'completion_date': datetime.now(),
            'passed': score_data['passed'],
            'certificate_id': f"CERT_{self.quiz_id}_{user_id}_{int(time.time())}"
        }</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Usage Example</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Creating and Managing Quizzes</span>
                        <button class="copy-btn" onclick="copyCode('quiz-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="quiz-usage" class="language-python"># Create a new quiz
quiz = Quiz(1, "Python Basics", "Test your Python knowledge", "teacher_123")
quiz.time_limit = 30  # 30 minutes
quiz.passing_score = 75
quiz.shuffle_questions = True

# Add questions to the quiz
q1 = Question(1, "What is Python?", "multiple_choice", 2)
q1.add_option("A snake", False)
q1.add_option("A programming language", True)
q1.add_option("A movie", False)

q2 = Question(2, "Python is interpreted", "true_false", 1)
q2.correct_answer = True

quiz.add_question(q1)
quiz.add_question(q2)

# Publish the quiz
if quiz.publish():
    print("Quiz published successfully!")

# Calculate score for user answers
user_answers = [1, True]  # User's responses
score_data = quiz.calculate_score(user_answers)
print(f"Score: {score_data['percentage']:.1f}%")
print(f"Passed: {score_data['passed']}")

# Generate certificate if passed
if score_data['passed']:
    cert_data = quiz.generate_certificate_data("user_456", score_data)
    print(f"Certificate ID: {cert_data['certificate_id']}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Quiz Result Section -->
        <section id="result-class" class="section">
            <h2><i class="fas fa-chart-bar"></i> Quiz Result Class</h2>
            
            <div class="description">
                <p>The <strong>QuizResult</strong> class tracks individual quiz attempts, recording answers, timing data, and implementing anti-cheating measures with detailed result analysis.</p>
            </div>

            <div class="features">
                <div class="feature-card">
                    <h4><i class="fas fa-stopwatch"></i> Time Tracking</h4>
                    <p>Precise timing for overall quiz and individual questions with performance analytics.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-shield-alt"></i> Cheating Detection</h4>
                    <p>Advanced algorithms to detect suspicious patterns and potential cheating attempts.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-list-alt"></i> Detailed Results</h4>
                    <p>Question-by-question breakdown with explanations and performance insights.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-database"></i> Session Management</h4>
                    <p>Comprehensive session tracking with IP addresses and user agent information.</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">QuizResult Class Implementation</span>
                    <button class="copy-btn" onclick="copyCode('result-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="result-code" class="language-python">class QuizResult:
    def __init__(self, result_id, user_id, quiz_id, attempt_number):
        self.result_id = result_id
        self.user_id = user_id
        self.quiz_id = quiz_id
        self.attempt_number = attempt_number
        self.start_time = datetime.now()
        self.end_time = None
        self.user_answers = []
        self.score_data = None
        self.time_taken = None
        self.is_completed = False
        self.ip_address = None
        self.user_agent = None
        self.cheating_flags = []
    
    def record_answer(self, question_index, answer, time_spent):
        """Record user answer for a question"""
        answer_data = {
            'question_index': question_index,
            'answer': answer,
            'time_spent': time_spent,
            'timestamp': datetime.now()
        }
        
        # Ensure we have enough slots in the answers list
        while len(self.user_answers) <= question_index:
            self.user_answers.append(None)
        
        self.user_answers[question_index] = answer_data
    
    def complete_quiz(self, quiz):
        """Complete the quiz and calculate final score"""
        self.end_time = datetime.now()
        self.time_taken = (self.end_time - self.start_time).total_seconds()
        
        # Extract just the answers for scoring
        answers_only = []
        for answer_data in self.user_answers:
            if answer_data:
                answers_only.append(answer_data['answer'])
            else:
                answers_only.append(None)
        
        self.score_data = quiz.calculate_score(answers_only)
        self.is_completed = True
        
        # Check for potential cheating indicators
        self.detect_cheating_patterns(quiz)
        
        return self.score_data
    
    def detect_cheating_patterns(self, quiz):
        """Detect potential cheating based on patterns"""
        if not self.time_taken:
            return
        
        questions = quiz.questions.to_list()
        
        # Check if completed too quickly
        min_expected_time = len(questions) * 30  # 30 seconds per question minimum
        if self.time_taken < min_expected_time:
            self.cheating_flags.append("Completed too quickly")
        
        # Check answer patterns
        self.check_answer_patterns()
        
        # Check time spent per question
        self.check_time_distribution()
    
    def get_detailed_results(self, quiz):
        """Get detailed results with question-by-question breakdown"""
        if not self.is_completed:
            return None
        
        questions = quiz.questions.to_list()
        detailed_results = []
        
        for i, question in enumerate(questions):
            answer_data = self.user_answers[i] if i < len(self.user_answers) else None
            user_answer = answer_data['answer'] if answer_data else None
            
            result = {
                'question_id': question.question_id,
                'question_text': question.text,
                'user_answer': user_answer,
                'correct_answer': question.correct_answer,
                'is_correct': question.check_answer(user_answer) if user_answer is not None else False,
                'points_earned': question.points * question.get_difficulty_multiplier() if question.check_answer(user_answer) else 0,
                'time_spent': answer_data['time_spent'] if answer_data else 0,
                'explanation': question.explanation
            }
            detailed_results.append(result)
        
        return detailed_results</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Usage Example</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Recording Quiz Results</span>
                        <button class="copy-btn" onclick="copyCode('result-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="result-usage" class="language-python"># Create a quiz result for tracking
result = QuizResult("result_001", "user_123", "quiz_456", 1)
result.ip_address = "192.168.1.100"
result.user_agent = "Mozilla/5.0..."

# Record answers as user progresses
result.record_answer(0, 1, 45)  # Question 0, answer 1, 45 seconds
result.record_answer(1, True, 30)  # Question 1, answer True, 30 seconds
result.record_answer(2, "Python", 60)  # Question 2, answer "Python", 60 seconds

# Complete the quiz
quiz = Quiz(456, "Python Test", "Basic Python quiz", "teacher_1")
# ... add questions to quiz ...

final_score = result.complete_quiz(quiz)
print(f"Final score: {final_score['percentage']:.1f}%")
print(f"Time taken: {result.time_taken} seconds")

# Check for cheating flags
if result.cheating_flags:
    print("Potential cheating detected:")
    for flag in result.cheating_flags:
        print(f"- {flag}")

# Get detailed results
detailed = result.get_detailed_results(quiz)
for i, detail in enumerate(detailed):
    print(f"Q{i+1}: {'✓' if detail['is_correct'] else '✗'} "
          f"({detail['time_spent']}s)")</code></pre>
                </div>
            </div>
        </section>

        <!-- Data Structures Section -->
        <section id="linked-list" class="section">
            <h2><i class="fas fa-link"></i> Data Structures Implementation</h2>
            
            <div class="description">
                <p>The platform implements custom data structures optimized for quiz management: a <strong>Doubly Linked List</strong> for question ordering, a <strong>Hash Map</strong> for score storage, and a <strong>Queue</strong> for exam flow management.</p>
            </div>

            <div class="data-structures">
                <div class="ds-card">
                    <h4><i class="fas fa-link"></i> Question Linked List</h4>
                    <p><strong>Purpose:</strong> Maintains question order with efficient insertion, deletion, and reordering operations.</p>
                    <p><strong>Features:</strong> Doubly-linked for bidirectional traversal, position-based operations, and shuffling support.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <li>Insert: O(1) at ends, O(n) at position</li>
                        <li>Delete: O(n) by ID, O(1) with node reference</li>
                        <li>Search: O(n)</li>
                    </ul>
                </div>
                
                <div class="ds-card">
                    <h4><i class="fas fa-hashtag"></i> User Score HashMap</h4>
                    <p><strong>Purpose:</strong> Fast storage and retrieval of user scores with collision handling and dynamic resizing.</p>
                    <p><strong>Features:</strong> Composite keys (user_id + quiz_id), load factor management, and statistical analysis.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <li>Insert/Get: O(1) average, O(n) worst case</li>
                        <li>Resize: O(n)</li>
                        <li>Statistics: O(n) for user/quiz aggregation</li>
                    </ul>
                </div>
            </div>

            <h3>Question Linked List Implementation</h3>
            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">QuestionLinkedList Class</span>
                    <button class="copy-btn" onclick="copyCode('linkedlist-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="linkedlist-code" class="language-python">class QuestionNode:
    def __init__(self, question):
        self.question = question
        self.next = None
        self.prev = None

class QuestionLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
        self.current_position = 0
    
    def append(self, question):
        """Add question to end of list - O(1)"""
        new_node = QuestionNode(question)
        
        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        
        self.size += 1
    
    def insert_at_position(self, position, question):
        """Insert question at specific position - O(n)"""
        if position <= 0:
            self.prepend(question)
            return
        
        if position >= self.size:
            self.append(question)
            return
        
        new_node = QuestionNode(question)
        current = self.head
        
        for _ in range(position):
            current = current.next
        
        new_node.next = current
        new_node.prev = current.prev
        current.prev.next = new_node
        current.prev = new_node
        
        self.size += 1
    
    def remove_by_id(self, question_id):
        """Remove question by ID - O(n)"""
        current = self.head
        
        while current:
            if current.question.question_id == question_id:
                # Update links
                if current.prev:
                    current.prev.next = current.next
                else:
                    self.head = current.next
                
                if current.next:
                    current.next.prev = current.prev
                else:
                    self.tail = current.prev
                
                self.size -= 1
                return current.question
            
            current = current.next
        
        return None
    
    def move_question(self, from_position, to_position):
        """Move question from one position to another - O(n)"""
        if (from_position < 0 or from_position >= self.size or
            to_position < 0 or to_position >= self.size):
            return False
        
        if from_position == to_position:
            return True
        
        # Get the question to move
        question = self.get_question_at_position(from_position)
        if not question:
            return False
        
        # Remove from current position
        self.remove_by_id(question.question_id)
        
        # Insert at new position
        self.insert_at_position(to_position, question)
        
        return True
    
    def shuffle(self):
        """Shuffle questions randomly - O(n)"""
        import random
        questions = self.to_list()
        random.shuffle(questions)
        
        # Rebuild the linked list with shuffled order
        self.clear()
        for question in questions:
            self.append(question)</code></pre>
            </div>
        </section>

        <!-- HashMap Section -->
        <section id="hashmap" class="section">
            <h3><i class="fas fa-hashtag"></i> User Score HashMap Implementation</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">UserScoreHashMap Class</span>
                    <button class="copy-btn" onclick="copyCode('hashmap-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="hashmap-code" class="language-python">class UserScoreHashMap:
    def __init__(self, initial_capacity=64):
        self.capacity = initial_capacity
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]
        self.load_factor_threshold = 0.75
    
    def _hash(self, key):
        """Hash function for user-quiz combinations - O(1)"""
        return hash(key) % self.capacity
    
    def _make_key(self, user_id, quiz_id):
        """Create composite key for user-quiz combination"""
        return f"{user_id}_{quiz_id}"
    
    def store_score(self, user_id, quiz_id, score_data):
        """Store user score for a quiz - O(1) average"""
        key = self._make_key(user_id, quiz_id)
        
        if self.size >= self.capacity * self.load_factor_threshold:
            self._resize()
        
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # Check if score already exists (update)
        for i, (stored_key, value) in enumerate(bucket):
            if stored_key == key:
                bucket[i] = (key, score_data)
                return
        
        # Add new score
        bucket.append((key, score_data))
        self.size += 1
    
    def get_score(self, user_id, quiz_id):
        """Get user score for a specific quiz - O(1) average"""
        key = self._make_key(user_id, quiz_id)
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for stored_key, value in bucket:
            if stored_key == key:
                return value
        return None
    
    def get_top_scores(self, quiz_id, limit=10):
        """Get top scores for a quiz - O(n log n)"""
        quiz_scores = self.get_quiz_scores(quiz_id)
        
        # Sort by percentage score (descending)
        sorted_scores = sorted(
            quiz_scores,
            key=lambda x: x['score_data']['percentage'],
            reverse=True
        )
        
        return sorted_scores[:limit]
    
    def calculate_user_statistics(self, user_id):
        """Calculate statistics for a user across all quizzes - O(n)"""
        user_scores = self.get_user_scores(user_id)
        
        if not user_scores:
            return {'total_quizzes': 0, 'average_score': 0, 'best_score': 0}
        
        percentages = [score['score_data']['percentage'] for score in user_scores]
        
        return {
            'total_quizzes': len(user_scores),
            'average_score': sum(percentages) / len(percentages),
            'best_score': max(percentages),
            'worst_score': min(percentages),
            'quizzes_passed': len([s for s in user_scores if s['score_data']['passed']])
        }
    
    def _resize(self):
        """Resize hash map when load factor exceeds threshold - O(n)"""
        old_buckets = self.buckets
        self.capacity *= 2
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]
        
        for bucket in old_buckets:
            for key, value in bucket:
                # Re-hash with new capacity
                index = self._hash(key)
                self.buckets[index].append((key, value))
                self.size += 1</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> HashMap Usage Example</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Using the Score HashMap</span>
                        <button class="copy-btn" onclick="copyCode('hashmap-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="hashmap-usage" class="language-python"># Create score storage system
score_map = UserScoreHashMap()

# Store user scores
score_data_1 = {'percentage': 85.5, 'points': 17, 'passed': True}
score_data_2 = {'percentage': 92.0, 'points': 23, 'passed': True}
score_data_3 = {'percentage': 67.5, 'points': 13, 'passed': False}

score_map.store_score("user_123", "quiz_001", score_data_1)
score_map.store_score("user_456", "quiz_001", score_data_2)
score_map.store_score("user_789", "quiz_001", score_data_3)

# Retrieve specific score
user_score = score_map.get_score("user_123", "quiz_001")
print(f"User 123 scored: {user_score['percentage']}%")

# Get top scores for a quiz
top_scores = score_map.get_top_scores("quiz_001", 3)
for i, score in enumerate(top_scores, 1):
    print(f"{i}. User {score['user_id']}: {score['score_data']['percentage']}%")

# Calculate user statistics
stats = score_map.calculate_user_statistics("user_123")
print(f"User 123 statistics:")
print(f"- Total quizzes: {stats['total_quizzes']}")
print(f"- Average score: {stats['average_score']:.1f}%")
print(f"- Best score: {stats['best_score']}%")</code></pre>
                </div>
            </div>
        </section>

        <!-- Queue Section -->
        <section id="queue" class="section">
            <h2><i class="fas fa-layer-group"></i> Exam Flow Queue</h2>
            
            <div class="description">
                <p>The <strong>ExamFlowQueue</strong> manages concurrent exam sessions using a queue-based system with session management, capacity control, and automatic cleanup of expired sessions.</p>
            </div>

            <div class="features">
                <div class="feature-card">
                    <h4><i class="fas fa-users"></i> Concurrent Management</h4>
                    <p>Handles multiple simultaneous exam sessions with configurable capacity limits.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-clock"></i> Session Tracking</h4>
                    <p>Comprehensive session lifecycle management with automatic expiration handling.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-chart-pie"></i> Queue Analytics</h4>
                    <p>Real-time queue status monitoring and capacity utilization metrics.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-hourglass-half"></i> Wait Time Estimation</h4>
                    <p>Intelligent wait time calculation based on current queue and average exam duration.</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">ExamFlowQueue Implementation</span>
                    <button class="copy-btn" onclick="copyCode('queue-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="queue-code" class="language-python">from collections import deque
import time

class ExamFlowQueue:
    def __init__(self):
        self.waiting_queue = deque()  # Users waiting to start
        self.active_exams = {}  # Currently taking exams
        self.completed_exams = []  # Finished exams
        self.exam_sessions = {}  # Session management
        self.max_concurrent_exams = 100
    
    def enqueue_user(self, user_id, quiz_id, priority=0):
        """Add user to exam waiting queue - O(1)"""
        exam_request = {
            'user_id': user_id,
            'quiz_id': quiz_id,
            'priority': priority,
            'enqueue_time': datetime.now(),
            'estimated_start_time': self.calculate_estimated_start_time()
        }
        
        self.waiting_queue.append(exam_request)
        return exam_request
    
    def start_next_exam(self):
        """Start exam for next user in queue - O(1)"""
        if (len(self.active_exams) >= self.max_concurrent_exams or 
            not self.waiting_queue):
            return None
        
        exam_request = self.waiting_queue.popleft()
        session_id = self.create_exam_session(exam_request)
        
        if session_id:
            self.active_exams[session_id] = {
                'user_id': exam_request['user_id'],
                'quiz_id': exam_request['quiz_id'],
                'start_time': datetime.now(),
                'current_question': 0,
                'answers': []
            }
            
            return session_id
        
        return None
    
    def submit_answer(self, session_id, question_index, answer):
        """Submit answer for current question - O(1)"""
        if session_id in self.active_exams:
            exam_data = self.active_exams[session_id]
            
            # Ensure answers list is long enough
            while len(exam_data['answers']) <= question_index:
                exam_data['answers'].append(None)
            
            exam_data['answers'][question_index] = {
                'answer': answer,
                'timestamp': datetime.now()
            }
            
            exam_data['current_question'] = question_index + 1
            return True
        
        return False
    
    def complete_exam(self, session_id, final_score=None):
        """Complete exam and move to completed queue - O(1)"""
        if session_id in self.active_exams:
            exam_data = self.active_exams[session_id]
            exam_data['end_time'] = datetime.now()
            exam_data['final_score'] = final_score
            
            # Move to completed exams
            self.completed_exams.append(exam_data)
            del self.active_exams[session_id]
            
            # Mark session as inactive
            if session_id in self.exam_sessions:
                self.exam_sessions[session_id]['is_active'] = False
            
            return True
        
        return False
    
    def get_queue_status(self):
        """Get current queue status - O(1)"""
        return {
            'waiting_count': len(self.waiting_queue),
            'active_exams': len(self.active_exams),
            'completed_today': len([e for e in self.completed_exams 
                                  if e['end_time'].date() == datetime.now().date()]),
            'capacity_utilization': len(self.active_exams) / self.max_concurrent_exams
        }
    
    def calculate_estimated_start_time(self):
        """Calculate estimated start time for queued users - O(1)"""
        if not self.waiting_queue:
            return datetime.now()
        
        # Assume average exam time of 45 minutes
        avg_exam_time = 45  # minutes
        
        # Calculate how many users are ahead
        available_slots = max(0, self.max_concurrent_exams - len(self.active_exams))
        queue_position = len(self.waiting_queue)
        
        if available_slots > 0:
            estimated_minutes = 0
        else:
            estimated_minutes = (queue_position / self.max_concurrent_exams) * avg_exam_time
        
        return datetime.now() + timedelta(minutes=estimated_minutes)</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Queue Usage Example</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Managing Exam Flow</span>
                        <button class="copy-btn" onclick="copyCode('queue-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="queue-usage" class="language-python"># Create exam flow manager
exam_queue = ExamFlowQueue()

# Add users to waiting queue
request1 = exam_queue.enqueue_user("user_123", "quiz_001")
request2 = exam_queue.enqueue_user("user_456", "quiz_001")
request3 = exam_queue.enqueue_user("user_789", "quiz_002", priority=1)

print(f"User 123 estimated start: {request1['estimated_start_time']}")

# Start exams for waiting users
session1 = exam_queue.start_next_exam()
session2 = exam_queue.start_next_exam()

print(f"Started sessions: {session1}, {session2}")

# Submit answers during exam
exam_queue.submit_answer(session1, 0, "A")
exam_queue.submit_answer(session1, 1, True)
exam_queue.submit_answer(session1, 2, "Python")

# Complete an exam
final_score = {'percentage': 85.0, 'passed': True}
exam_queue.complete_exam(session1, final_score)

# Check queue status
status = exam_queue.get_queue_status()
print(f"Queue Status:")
print(f"- Waiting: {status['waiting_count']}")
print(f"- Active: {status['active_exams']}")
print(f"- Capacity: {status['capacity_utilization']:.1%}")

# Cleanup expired sessions
exam_queue.cleanup_expired_sessions()</code></pre>
                </div>
            </div>
        </section>

        <!-- Algorithms Section -->
        <section id="algorithms" class="section">
            <h2><i class="fas fa-calculator"></i> Scoring Algorithms</h2>
            
            <div class="description">
                <p>The platform implements multiple sophisticated <strong>scoring algorithms</strong> to accommodate different assessment needs, from standard scoring to adaptive difficulty-based evaluation.</p>
            </div>

            <div class="algorithms">
                <div class="algo-card">
                    <h4><i class="fas fa-equals"></i> Standard Scoring</h4>
                    <p><strong>Method:</strong> 1 point per correct answer</p>
                    <p><strong>Use Case:</strong> Simple quizzes and basic assessments</p>
                    <p><strong>Complexity:</strong> O(n) where n = number of questions</p>
                </div>
                
                <div class="algo-card">
                    <h4><i class="fas fa-weight-hanging"></i> Weighted Difficulty</h4>
                    <p><strong>Method:</strong> Points multiplied by difficulty level</p>
                    <p><strong>Use Case:</strong> Comprehensive exams with varying question difficulty</p>
                    <p><strong>Complexity:</strong> O(n) with difficulty calculations</p>
                </div>
                
                <div class="algo-card">
                    <h4><i class="fas fa-minus-circle"></i> Negative Marking</h4>
                    <p><strong>Method:</strong> Deduct points for incorrect answers</p>
                    <p><strong>Use Case:</strong> Competitive exams and professional certifications</p>
                    <p><strong>Complexity:</strong> O(n) with penalty calculations</p>
                </div>
                
                <div class="algo-card">
                    <h4><i class="fas fa-brain"></i> Adaptive Scoring</h4>
                    <p><strong>Method:</strong> Dynamic scoring based on question performance history</p>
                    <p><strong>Use Case:</strong> Personalized assessments and skill evaluation</p>
                    <p><strong>Complexity:</strong> O(n) with statistical analysis</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">Scoring Algorithms Implementation</span>
                    <button class="copy-btn" onclick="copyCode('scoring-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="scoring-code" class="language-python">def calculate_weighted_score(answers, questions, scoring_method='standard'):
    """
    Calculate quiz score using various scoring methods
    Time Complexity: O(n) where n is number of questions
    """
    if scoring_method == 'standard':
        return calculate_standard_score(answers, questions)
    elif scoring_method == 'weighted_difficulty':
        return calculate_difficulty_weighted_score(answers, questions)
    elif scoring_method == 'negative_marking':
        return calculate_negative_marking_score(answers, questions)
    elif scoring_method == 'adaptive':
        return calculate_adaptive_score(answers, questions)

def calculate_standard_score(answers, questions):
    """Standard scoring: 1 point per correct answer"""
    correct_count = 0
    total_count = len(questions)
    
    for i, question in enumerate(questions):
        if i < len(answers) and answers[i] is not None:
            if question.check_answer(answers[i]):
                correct_count += 1
    
    percentage = (correct_count / total_count * 100) if total_count > 0 else 0
    
    return {
        'correct_count': correct_count,
        'total_count': total_count,
        'percentage': percentage,
        'total_points': correct_count,
        'max_points': total_count,
        'scoring_method': 'standard'
    }

def calculate_difficulty_weighted_score(answers, questions):
    """Difficulty-weighted scoring: harder questions worth more points"""
    earned_points = 0
    max_points = 0
    correct_count = 0
    
    for i, question in enumerate(questions):
        question_points = question.points * question.get_difficulty_multiplier()
        max_points += question_points
        
        if i < len(answers) and answers[i] is not None:
            if question.check_answer(answers[i]):
                earned_points += question_points
                correct_count += 1
    
    percentage = (earned_points / max_points * 100) if max_points > 0 else 0
    
    return {
        'correct_count': correct_count,
        'total_count': len(questions),
        'percentage': percentage,
        'total_points': earned_points,
        'max_points': max_points,
        'scoring_method': 'weighted_difficulty'
    }

def calculate_negative_marking_score(answers, questions, penalty_factor=0.25):
    """Negative marking: deduct points for wrong answers"""
    earned_points = 0
    max_points = 0
    correct_count = 0
    incorrect_count = 0
    
    for i, question in enumerate(questions):
        question_points = question.points * question.get_difficulty_multiplier()
        max_points += question_points
        
        if i < len(answers) and answers[i] is not None:
            if question.check_answer(answers[i]):
                earned_points += question_points
                correct_count += 1
            else:
                # Negative marking
                earned_points -= question_points * penalty_factor
                incorrect_count += 1
    
    # Ensure score doesn't go below 0
    earned_points = max(0, earned_points)
    percentage = (earned_points / max_points * 100) if max_points > 0 else 0
    
    return {
        'correct_count': correct_count,
        'incorrect_count': incorrect_count,
        'total_count': len(questions),
        'percentage': percentage,
        'total_points': earned_points,
        'max_points': max_points,
        'penalty_applied': incorrect_count * penalty_factor,
        'scoring_method': 'negative_marking'
    }

def calculate_adaptive_score(answers, questions):
    """Adaptive scoring: adjust points based on question performance"""
    earned_points = 0
    max_points = 0
    correct_count = 0
    
    for i, question in enumerate(questions):
        # Base points adjusted by question difficulty and success rate
        base_points = question.points
        difficulty_multiplier = question.get_difficulty_multiplier()
        
        # Questions with lower success rates are worth more
        success_rate_multiplier = 2.0 - question.success_rate  # Range: 1.0 to 2.0
        
        question_points = base_points * difficulty_multiplier * success_rate_multiplier
        max_points += question_points
        
        if i < len(answers) and answers[i] is not None:
            if question.check_answer(answers[i]):
                earned_points += question_points
                correct_count += 1
    
    percentage = (earned_points / max_points * 100) if max_points > 0 else 0
    
    return {
        'correct_count': correct_count,
        'total_count': len(questions),
        'percentage': percentage,
        'total_points': earned_points,
        'max_points': max_points,
        'scoring_method': 'adaptive'
    }</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Scoring Algorithm Usage</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Using Different Scoring Methods</span>
                        <button class="copy-btn" onclick="copyCode('scoring-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="scoring-usage" class="language-python"># Create sample questions with different difficulties
questions = [
    Question(1, "Easy question", "multiple_choice", 1),  # Difficulty 1
    Question(2, "Medium question", "multiple_choice", 3),  # Difficulty 3
    Question(3, "Hard question", "multiple_choice", 5),   # Difficulty 5
]

# Set up questions
questions[0].points = 1
questions[1].points = 1
questions[2].points = 1

# User answers: [correct, correct, incorrect]
user_answers = [0, 1, 2]  # Assume these are correct, correct, incorrect

# Test different scoring methods
print("=== Scoring Method Comparison ===")

# Standard scoring
standard = calculate_weighted_score(user_answers, questions, 'standard')
print(f"Standard: {standard['percentage']:.1f}% ({standard['correct_count']}/{standard['total_count']})")

# Weighted difficulty scoring
weighted = calculate_weighted_score(user_answers, questions, 'weighted_difficulty')
print(f"Weighted: {weighted['percentage']:.1f}% ({weighted['total_points']:.1f}/{weighted['max_points']:.1f} pts)")

# Negative marking scoring
negative = calculate_weighted_score(user_answers, questions, 'negative_marking')
print(f"Negative Marking: {negative['percentage']:.1f}% (penalty: {negative['penalty_applied']:.1f})")

# Adaptive scoring (requires success rate data)
for q in questions:
    q.success_rate = 0.6  # 60% success rate
adaptive = calculate_weighted_score(user_answers, questions, 'adaptive')
print(f"Adaptive: {adaptive['percentage']:.1f}% ({adaptive['total_points']:.1f}/{adaptive['max_points']:.1f} pts)")</code></pre>
                </div>
            </div>
        </section>

        <!-- Question Generation Section -->
        <section id="generation" class="section">
            <h2><i class="fas fa-random"></i> Question Generation Algorithms</h2>
            
            <div class="description">
                <p>Advanced <strong>question generation algorithms</strong> create personalized quizzes using random selection with difficulty distribution and adaptive algorithms based on user performance history.</p>
            </div>

            <div class="algorithms">
                <div class="algo-card">
                    <h4><i class="fas fa-dice"></i> Random Generation</h4>
                    <p><strong>Method:</strong> Stratified sampling by difficulty levels</p>
                    <p><strong>Features:</strong> Configurable difficulty distribution, balanced question selection</p>
                    <p><strong>Complexity:</strong> O(n log n) for sorting and selection</p>
                </div>
                
                <div class="algo-card">
                    <h4><i class="fas fa-user-cog"></i> Adaptive Generation</h4>
                    <p><strong>Method:</strong> Performance-based question selection</p>
                    <p><strong>Features:</strong> Weakness analysis, personalized difficulty adjustment</p>
                    <p><strong>Complexity:</strong> O(n) for scoring and selection</p>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">Question Generation Algorithms</span>
                    <button class="copy-btn" onclick="copyCode('generation-code')">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
                </div>
                <pre><code id="generation-code" class="language-python">import random

def generate_random_quiz(question_pool, num_questions, difficulty_distribution=None):
    """
    Generate random quiz from question pool with difficulty distribution
    Time Complexity: O(n log n) where n is pool size
    """
    if difficulty_distribution is None:
        difficulty_distribution = {1: 0.1, 2: 0.2, 3: 0.4, 4: 0.2, 5: 0.1}
    
    # Group questions by difficulty
    questions_by_difficulty = {}
    for question in question_pool:
        difficulty = question.difficulty_level
        if difficulty not in questions_by_difficulty:
            questions_by_difficulty[difficulty] = []
        questions_by_difficulty[difficulty].append(question)
    
    selected_questions = []
    
    for difficulty, proportion in difficulty_distribution.items():
        if difficulty in questions_by_difficulty:
            questions_needed = int(num_questions * proportion)
            available_questions = questions_by_difficulty[difficulty]
            
            if len(available_questions) >= questions_needed:
                selected = random.sample(available_questions, questions_needed)
            else:
                selected = available_questions.copy()
            
            selected_questions.extend(selected)
    
    # Fill remaining slots if needed
    while len(selected_questions) < num_questions:
        remaining_questions = [q for q in question_pool if q not in selected_questions]
        if not remaining_questions:
            break
        selected_questions.append(random.choice(remaining_questions))
    
    # Shuffle the final selection
    random.shuffle(selected_questions)
    return selected_questions[:num_questions]

def generate_adaptive_quiz(question_pool, user_performance_history, target_difficulty=3):
    """
    Generate personalized quiz based on user's past performance
    Time Complexity: O(n) where n is question pool size
    """
    user_weak_topics = analyze_user_weaknesses(user_performance_history)
    user_avg_performance = calculate_average_performance(user_performance_history)
    
    # Adjust target difficulty based on user performance
    if user_avg_performance > 80:
        target_difficulty = min(5, target_difficulty + 1)
    elif user_avg_performance < 60:
        target_difficulty = max(1, target_difficulty - 1)
    
    # Score questions based on relevance to user
    scored_questions = []
    
    for question in question_pool:
        score = 0
        
        # Prefer questions in user's weak topics
        if question.category in user_weak_topics:
            score += 3
        
        # Prefer questions near target difficulty
        difficulty_diff = abs(question.difficulty_level - target_difficulty)
        score += (5 - difficulty_diff)
        
        # Prefer questions user hasn't seen recently
        if not recently_answered(question, user_performance_history):
            score += 2
        
        # Prefer questions with appropriate success rate
        if 0.3 <= question.success_rate <= 0.7:  # Challenging but fair
            score += 1
        
        scored_questions.append((question, score))
    
    # Sort by score and select top questions
    scored_questions.sort(key=lambda x: x[1], reverse=True)
    
    # Take top 50% and randomly select from them for variety
    top_half = scored_questions[:len(scored_questions)//2]
    selected_questions = [q[0] for q in random.sample(top_half, min(20, len(top_half)))]
    
    return selected_questions

def shuffle_question_options(questions):
    """
    Shuffle options for multiple choice questions
    Time Complexity: O(n * m) where n = questions, m = avg options per question
    """
    shuffled_questions = []
    
    for question in questions:
        if question.question_type == 'multiple_choice' and question.options:
            # Create a copy of the question
            new_question = copy.deepcopy(question)
            
            # Create mapping of old to new positions
            original_options = new_question.options.copy()
            random.shuffle(new_question.options)
            
            # Update correct answer index
            for new_index, option in enumerate(new_question.options):
                if option['is_correct']:
                    new_question.correct_answer = new_index
                    break
            
            shuffled_questions.append(new_question)
        else:
            shuffled_questions.append(question)
    
    return shuffled_questions

def analyze_user_weaknesses(performance_history):
    """Analyze user performance to identify weak topics"""
    topic_performance = {}
    
    for result in performance_history:
        for question_result in result.get('question_results', []):
            topic = question_result.get('category', 'general')
            
            if topic not in topic_performance:
                topic_performance[topic] = {'correct': 0, 'total': 0}
            
            topic_performance[topic]['total'] += 1
            if question_result.get('is_correct', False):
                topic_performance[topic]['correct'] += 1
    
    # Find topics with performance below 70%
    weak_topics = []
    for topic, stats in topic_performance.items():
        if stats['total'] > 0:
            performance = stats['correct'] / stats['total']
            if performance < 0.7:
                weak_topics.append(topic)
    
    return weak_topics

def calculate_average_performance(performance_history):
    """Calculate user's average performance across all quizzes"""
    if not performance_history:
        return 0
    
    total_percentage = sum(result.get('percentage', 0) for result in performance_history)
    return total_percentage / len(performance_history)

def recently_answered(question, performance_history, days_threshold=30):
    """Check if user answered this question recently"""
    from datetime import datetime, timedelta
    
    cutoff_date = datetime.now() - timedelta(days=days_threshold)
    
    for result in performance_history:
        result_date = result.get('completion_date', datetime.now())
        if result_date > cutoff_date:
            question_results = result.get('question_results', [])
            for q_result in question_results:
                if q_result.get('question_id') == question.question_id:
                    return True
    
    return False</code></pre>
            </div>

            <div class="usage-example">
                <h4><i class="fas fa-play"></i> Question Generation Usage</h4>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-title">Generating Personalized Quizzes</span>
                        <button class="copy-btn" onclick="copyCode('generation-usage')">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <pre><code id="generation-usage" class="language-python"># Create a question pool
question_pool = []
for i in range(100):
    difficulty = random.randint(1, 5)
    category = random.choice(['Math', 'Science', 'History', 'Literature'])
    question = Question(i, f"Question {i}", "multiple_choice", difficulty)
    question.category = category
    question.success_rate = random.uniform(0.3, 0.9)
    question_pool.append(question)

# Generate random quiz with custom difficulty distribution
difficulty_dist = {1: 0.2, 2: 0.3, 3: 0.3, 4: 0.15, 5: 0.05}
random_quiz = generate_random_quiz(question_pool, 20, difficulty_dist)

print(f"Random Quiz Generated: {len(random_quiz)} questions")
difficulty_counts = {}
for q in random_quiz:
    difficulty_counts[q.difficulty_level] = difficulty_counts.get(q.difficulty_level, 0) + 1
print(f"Difficulty distribution: {difficulty_counts}")

# Generate adaptive quiz based on user performance
user_history = [
    {
        'percentage': 65,
        'completion_date': datetime.now() - timedelta(days=10),
        'question_results': [
            {'question_id': 1, 'category': 'Math', 'is_correct': False},
            {'question_id': 5, 'category': 'Science', 'is_correct': True},
            {'question_id': 12, 'category': 'Math', 'is_correct': False},
        ]
    },
    {
        'percentage': 78,
        'completion_date': datetime.now() - timedelta(days=5),
        'question_results': [
            {'question_id': 3, 'category': 'History', 'is_correct': True},
            {'question_id': 8, 'category': 'Math', 'is_correct': False},
        ]
    }
]

adaptive_quiz = generate_adaptive_quiz(question_pool, user_history, target_difficulty=3)
print(f"Adaptive Quiz Generated: {len(adaptive_quiz)} questions")

# Analyze user weaknesses
weak_topics = analyze_user_weaknesses(user_history)
print(f"User weak topics: {weak_topics}")

avg_performance = calculate_average_performance(user_history)
print(f"User average performance: {avg_performance:.1f}%")

# Shuffle question options
shuffled_quiz = shuffle_question_options(adaptive_quiz)
print(f"Questions shuffled: {len(shuffled_quiz)} questions with randomized options")</code></pre>
                </div>
            </div>
        </section>

        <!-- Scrollspy Navigation -->
        <nav class="scrollspy-nav">
            <a href="#question-class">Question</a>
            <a href="#quiz-class">Quiz</a>
            <a href="#result-class">Result</a>
            <a href="#linked-list">Linked List</a>
            <a href="#hashmap">HashMap</a>
            <a href="#queue">Queue</a>
            <a href="#algorithms">Algorithms</a>
            <a href="#generation">Generation</a>
        </nav>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="toast">
        <i class="fas fa-check"></i> Code copied to clipboard!
    </div>

    <script>
        // Copy code functionality
        function copyCode(elementId) {
            const codeElement = document.getElementById(elementId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                showToast();
                
                // Update button temporarily
                const button = event.target.closest('.copy-btn');
                const originalHTML = button.innerHTML;
                button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        // Show toast notification
        function showToast() {
            const toast = document.getElementById('toast');
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Smooth scrolling for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.scrollspy-nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }

        // Update active navigation on scroll
        window.addEventListener('scroll', updateActiveNav);
        
        // Initialize active navigation
        updateActiveNav();

        // Add loading animation
        window.addEventListener('load', () => {
            document.body.style.opacity = '0';
            document.body.style.transition = 'opacity 0.5s ease-in-out';
            
            setTimeout(() => {
                document.body.style.opacity = '1';
            }, 100);
        });

        // Prism.js configuration
        Prism.highlightAll();
    </script>
</body>
</html>