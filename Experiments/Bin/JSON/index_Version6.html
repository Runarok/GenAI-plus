<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Object Fixer - Dark Theme</title>
    <link rel="icon" href="https://raw.githubusercontent.com/Runarok/GenAI-plus/main/GenAI-plus.png" type="image/png">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 1rem;
            border-bottom: 2px solid #404040;
            text-align: center;
        }

        .header h1 {
            color: #61dafb;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .container {
            display: flex;
            height: calc(100vh - 80px);
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #404040;
        }

        .panel:last-child {
            border-right: none;
        }

        .panel-header {
            background: #333;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #404040;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .input-panel .panel-header {
            color: #ff6b6b;
        }

        .output-panel .panel-header {
            color: #51cf66;
        }

        .error-count {
            background: #ff4757;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
        }

        .success-count {
            background: #2ed573;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .panel-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #input {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: none;
            padding: 1rem;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
        }

        #input:focus {
            background: #252525;
        }

        #output {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 1rem;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .error-list {
            background: #2d1b1b;
            border-top: 1px solid #404040;
            max-height: 150px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .error-item {
            background: #3d2626;
            border: 1px solid #ff4757;
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .error-item:last-child {
            margin-bottom: 0;
        }

        .error-type {
            color: #ff6b6b;
            font-weight: bold;
        }

        .error-description {
            color: #ffb3b3;
            margin-top: 0.25rem;
        }

        .toolbar {
            background: #2d2d2d;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #404040;
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            background: #404040;
            color: #e0e0e0;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #505050;
        }

        .btn.primary {
            background: #61dafb;
            color: #1a1a1a;
        }

        .btn.primary:hover {
            background: #4fa8c5;
        }

        /* Syntax highlighting for output */
        .json-key {
            color: #79c0ff;
        }

        .json-string {
            color: #a5d6ff;
        }

        .json-number {
            color: #79c0ff;
        }

        .json-boolean {
            color: #ff7b72;
        }

        .json-null {
            color: #8b949e;
        }

        .json-punctuation {
            color: #c9d1d9;
        }

        .highlight-fix {
            background: rgba(46, 213, 115, 0.2);
            border-radius: 2px;
            padding: 0 2px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .panel {
                border-right: none;
                border-bottom: 2px solid #404040;
            }
            
            .panel:last-child {
                border-bottom: none;
            }
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid #2ed573;
        }

        .toast.error {
            border-left: 4px solid #ff4757;
        }

        .toast.warning {
            border-left: 4px solid #ffa502;
        }

        .toast.info {
            border-left: 4px solid #3742fa;
        }

        .toast-icon {
            font-size: 18px;
            margin-top: 2px;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .toast-message {
            font-size: 13px;
            color: #b0b0b0;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            margin-left: 8px;
        }

        .toast-close:hover {
            color: #fff;
        }

        /* Line number highlighting */
        .line-highlight {
            background: rgba(255, 71, 87, 0.2);
            border-left: 3px solid #ff4757;
            padding-left: 8px;
            margin-left: -8px;
        }

        /* Auto-refresh indicator */
        .refresh-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #61dafb;
            color: #1a1a1a;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .refresh-indicator.active {
            opacity: 1;
        }

        /* Enhanced error display */
        .error-item {
            background: #3d2626;
            border: 1px solid #ff4757;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            position: relative;
        }

        .error-line {
            background: #ff4757;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
        }

        .error-details {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #555;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>
    <div class="header">
        <h1>🔧 JSON Object Fixer</h1>
        <p>Paste your malformed JavaScript objects or JSON below and get them fixed automatically</p>
    </div>

    <div class="container">
        <div class="panel input-panel">
            <div class="panel-header">
                Input (Malformed)
                <div style="position: relative;">
                    <span class="refresh-indicator" id="refreshIndicator">Auto-updating...</span>
                    <span class="error-count" id="errorCount">0 errors</span>
                </div>
            </div>
            <div class="toolbar">
                <button class="btn" onclick="clearInput()">Clear</button>
                <button class="btn" onclick="loadExample()">Load Example</button>
                <button class="btn primary" onclick="formatOutput()">Format Output</button>
            </div>
            <div class="panel-content">
                <textarea id="input" placeholder="Paste your malformed JSON or JavaScript object here...

Example:
{
  name: 'John Doe',
  age: 30,
  city: 'New York'
  hobbies: ['reading', 'coding', 'gaming',]
  isActive: true,
}"></textarea>
            </div>
            <div class="error-list" id="errorList"></div>
        </div>

        <div class="panel output-panel">
            <div class="panel-header">
                Output (Fixed)
                <span class="success-count" id="successIndicator">Ready</span>
            </div>
            <div class="toolbar">
                <button class="btn" onclick="copyOutput()">Copy</button>
                <button class="btn" onclick="downloadOutput()">Download</button>
                <button class="btn" onclick="validateOutput()">Validate</button>
            </div>
            <div class="panel-content">
                <pre id="output">Your fixed JSON will appear here...</pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script>
        class JSONFixer {
    constructor() {
        this.errors = [];
        this.fixes = [];
        this.inputLines = [];
    }

    fix(input) {
        this.errors = [];
        this.fixes = [];
        this.inputLines = input.split('\n');
        
        if (!input.trim()) {
            return { fixed: '', errors: [], fixes: [] };
        }

        let fixed = input;
        
        // Step 1: Handle JavaScript object syntax (unquoted keys)
        fixed = this.fixUnquotedKeys(fixed);
        
        // Step 2: Fix single quotes to double quotes
        fixed = this.fixQuotes(fixed);
        
        // Step 3: Fix trailing commas
        fixed = this.fixTrailingCommas(fixed);
        
        // Step 4: Fix missing commas
        fixed = this.fixMissingCommas(fixed);
        
        // Step 5: Fix bracket/brace matching
        fixed = this.fixBrackets(fixed);
        
        // Step 6: Fix missing colons
        fixed = this.fixMissingColons(fixed);
        
        // Step 7: Try to parse and catch remaining errors
        this.validateJSON(fixed);
        
        return {
            fixed: fixed,
            errors: this.errors,
            fixes: this.fixes
        };
    }

    getLineNumber(text, position) {
        const beforePosition = text.substring(0, position);
        return beforePosition.split('\n').length;
    }

    findErrorLine(text, searchPattern) {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes(searchPattern)) {
                return i + 1;
            }
        }
        return 1;
    }

    fixUnquotedKeys(str) {
        const regex = /([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g;
        let match;
        const fixes = [];
        
        while ((match = regex.exec(str)) !== null) {
            const lineNum = this.getLineNumber(str, match.index);
            fixes.push({
                key: match[2],
                line: lineNum,
                description: `Unquoted key "${match[2]}" on line ${lineNum}`
            });
        }
        
        const result = str.replace(regex, (match, prefix, key) => {
            return `${prefix}"${key}":`;
        });
        
        if (fixes.length > 0) {
            this.addFix(`Added quotes around ${fixes.length} unquoted key(s)`, fixes);
        }
        
        return result;
    }

    fixQuotes(str) {
        let result = '';
        let inString = false;
        let stringChar = '';
        let escaped = false;
        let singleQuoteCount = 0;
        let currentLine = 1;
        
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            
            if (char === '\n') currentLine++;
            
            if (!inString && (char === '"' || char === "'")) {
                inString = true;
                stringChar = char;
                result += '"';
                if (char === "'") {
                    singleQuoteCount++;
                }
            } else if (inString && char === stringChar && !escaped) {
                inString = false;
                result += '"';
            } else if (inString && char === '"' && stringChar === "'") {
                result += '\\"';
            } else {
                result += char;
            }
            
            escaped = char === '\\' && !escaped;
        }
        
        if (singleQuoteCount > 0) {
            this.addFix(`Converted ${singleQuoteCount} single quotes to double quotes`);
        }
        
        return result;
    }

    fixTrailingCommas(str) {
        const regex = /,(\s*[}\]])/g;
        let match;
        const trailingCommas = [];
        
        while ((match = regex.exec(str)) !== null) {
            const lineNum = this.getLineNumber(str, match.index);
            trailingCommas.push(lineNum);
        }
        
        const fixed = str.replace(regex, '$1');
        
        if (trailingCommas.length > 0) {
            this.addFix(`Removed ${trailingCommas.length} trailing comma(s)`, 
                trailingCommas.map(line => ({ line, description: `Trailing comma on line ${line}` })));
        }
        
        return fixed;
    }

    fixMissingCommas(str) {
        let result = str;
        let fixCount = 0;
        
        // Between object properties
        const objRegex = /}(\s*)"([^"]+)":/g;
        let match;
        while ((match = objRegex.exec(str)) !== null) {
            const lineNum = this.getLineNumber(str, match.index);
            fixCount++;
        }
        result = result.replace(objRegex, (match, space, key) => {
            return `},${space}"${key}":`;
        });
        
        if (fixCount > 0) {
            this.addFix(`Added ${fixCount} missing comma(s) between object properties`);
        }
        
        return result;
    }

    fixBrackets(str) {
        const stack = [];
        let openCount = { '{': 0, '[': 0 };
        let closeCount = { '}': 0, ']': 0 };
        let currentLine = 1;
        let unmatchedOpeners = [];
        
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            if (char === '\n') currentLine++;
            
            if (char === '{' || char === '[') {
                openCount[char]++;
                stack.push({ char, line: currentLine, index: i });
            } else if (char === '}' || char === ']') {
                closeCount[char]++;
                const expected = char === '}' ? '{' : '[';
                const lastOpen = stack[stack.length - 1];
                
                if (!lastOpen || lastOpen.char !== expected) {
                    this.addError("Bracket Mismatch", 
                        `Unexpected '${char}' on line ${currentLine}. Expected closing for '${lastOpen ? lastOpen.char : 'none'}' opened on line ${lastOpen ? lastOpen.line : 'unknown'}.`, 
                        currentLine);
                } else {
                    stack.pop();
                }
            }
        }
        
        // Report unclosed brackets
        stack.forEach(item => {
            this.addError("Unclosed Bracket", 
                `Unclosed '${item.char}' opened on line ${item.line}`, 
                item.line);
        });
        
        let result = str;
        const missingBraces = openCount['{'] - closeCount['}'];
        const missingBrackets = openCount['['] - closeCount[']'];
        
        if (missingBraces > 0) {
            result += '}'.repeat(missingBraces);
            this.addFix(`Added ${missingBraces} missing closing brace(s)`);
        }
        
        if (missingBrackets > 0) {
            result += ']'.repeat(missingBrackets);
            this.addFix(`Added ${missingBrackets} missing closing bracket(s)`);
        }
        
        return result;
    }

    fixMissingColons(str) {
        const regex = /"([^"]+)"\s+"([^"]+)"/g;
        let match;
        let fixCount = 0;
        
        while ((match = regex.exec(str)) !== null) {
            const lineNum = this.getLineNumber(str, match.index);
            fixCount++;
        }
        
        const fixed = str.replace(regex, (match, key, value) => {
            return `"${key}": "${value}"`;
        });
        
        if (fixCount > 0) {
            this.addFix(`Added ${fixCount} missing colon(s)`);
        }
        
        return fixed;
    }

    validateJSON(str) {
        try {
            JSON.parse(str);
        } catch (error) {
            const match = error.message.match(/position (\d+)/);
            let lineNum = 1;
            
            if (match) {
                const position = parseInt(match[1]);
                lineNum = this.getLineNumber(str, position);
            } else {
                // Try to extract line number from error message
                const lineMatch = error.message.match(/line (\d+)/);
                if (lineMatch) {
                    lineNum = parseInt(lineMatch[1]);
                }
            }
            
            this.addError("JSON Syntax Error", error.message, lineNum);
        }
    }

    addError(type, description, line = null) {
        this.errors.push({ type, description, line });
    }

    addFix(description, details = null) {
        this.fixes.push({ description, details });
    }
}

class ToastManager {
    constructor() {
        this.container = document.getElementById('toastContainer');
        this.toasts = [];
    }

    show(type, title, message, duration = 5000) {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: '✅',
            error: '❌',
            warning: '⚠️',
            info: 'ℹ️'
        };
        
        toast.innerHTML = `
            <div class="toast-icon">${icons[type] || 'ℹ️'}</div>
            <div class="toast-content">
                <div class="toast-title">${title}</div>
                <div class="toast-message">${message}</div>
            </div>
            <button class="toast-close" onclick="toastManager.remove(this.parentElement)">×</button>
        `;
        
        this.container.appendChild(toast);
        this.toasts.push(toast);
        
        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Auto remove
        if (duration > 0) {
            setTimeout(() => this.remove(toast), duration);
        }
        
        return toast;
    }

    remove(toast) {
        if (toast && toast.parentElement) {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.parentElement.removeChild(toast);
                    this.toasts = this.toasts.filter(t => t !== toast);
                }
            }, 300);
        }
    }

    clear() {
        this.toasts.forEach(toast => this.remove(toast));
    }
}

const fixer = new JSONFixer();
const toastManager = new ToastManager();
let currentOutput = '';
let refreshTimeout;
let isProcessing = false;

function showRefreshIndicator() {
    const indicator = document.getElementById('refreshIndicator');
    indicator.classList.add('active');
    setTimeout(() => indicator.classList.remove('active'), 1000);
}

function processInput() {
    if (isProcessing) return;
    isProcessing = true;
    
    showRefreshIndicator();
    
    const input = document.getElementById('input').value;
    const result = fixer.fix(input);
    
    currentOutput = result.fixed;
    displayOutput(result.fixed, result.fixes);
    displayErrors(result.errors);
    updateCounters(result.errors.length, result.fixes.length);
    
    // Show toast notifications
    if (result.fixes.length > 0) {
        toastManager.show('success', 'Fixes Applied', 
            `Applied ${result.fixes.length} fix${result.fixes.length !== 1 ? 'es' : ''} to your JSON`);
    }
    
    if (result.errors.length > 0) {
        const errorLines = result.errors.filter(e => e.line).map(e => e.line).join(', ');
        toastManager.show('error', 'Errors Detected', 
            `Found ${result.errors.length} error${result.errors.length !== 1 ? 's' : ''} ${errorLines ? `on line${result.errors.length > 1 ? 's' : ''}: ${errorLines}` : ''}`);
    }
    
    isProcessing = false;
}

function displayOutput(output, fixes) {
    const outputElement = document.getElementById('output');
    
    if (!output.trim()) {
        outputElement.textContent = 'Your fixed JSON will appear here...';
        return;
    }
    
    try {
        const parsed = JSON.parse(output);
        const formatted = JSON.stringify(parsed, null, 2);
        outputElement.innerHTML = highlightJSON(formatted);
    } catch (error) {
        outputElement.innerHTML = highlightJSON(output);
    }
}

function highlightJSON(json) {
    return json
        .replace(/("([^"\\]|\\.)*")\s*:/g, '<span class="json-key">$1</span>:')
        .replace(/:\s*("([^"\\]|\\.)*")/g, ': <span class="json-string">$1</span>')
        .replace(/:\s*(-?\d+\.?\d*)/g, ': <span class="json-number">$1</span>')
        .replace(/:\s*(true|false)/g, ': <span class="json-boolean">$1</span>')
        .replace(/:\s*(null)/g, ': <span class="json-null">$1</span>')
        .replace(/([{}[\],])/g, '<span class="json-punctuation">$1</span>');
}

function displayErrors(errors) {
    const errorList = document.getElementById('errorList');
    
    if (errors.length === 0) {
        errorList.style.display = 'none';
        return;
    }
    
    errorList.style.display = 'block';
    errorList.innerHTML = errors.map(error => `
        <div class="error-item">
            ${error.line ? `<span class="error-line">Line ${error.line}</span>` : ''}
            <div class="error-type">${error.type}</div>
            <div class="error-description">${error.description}</div>
            ${error.line ? `<div class="error-details">Check line ${error.line} in your input for this issue.</div>` : ''}
        </div>
    `).join('');
}

function updateCounters(errorCount, fixCount) {
    const errorCounter = document.getElementById('errorCount');
    const successIndicator = document.getElementById('successIndicator');
    
    errorCounter.textContent = `${errorCount} error${errorCount !== 1 ? 's' : ''}`;
    
    if (errorCount === 0 && fixCount > 0) {
        successIndicator.textContent = `${fixCount} fix${fixCount !== 1 ? 'es' : ''} applied`;
        successIndicator.style.background = '#2ed573';
    } else if (errorCount > 0) {
        successIndicator.textContent = 'Has errors';
        successIndicator.style.background = '#ff4757';
    } else {
        successIndicator.textContent = 'Ready';
        successIndicator.style.background = '#404040';
    }
}

function clearInput() {
    document.getElementById('input').value = '';
    document.getElementById('output').textContent = 'Your fixed JSON will appear here...';
    document.getElementById('errorList').style.display = 'none';
    updateCounters(0, 0);
    toastManager.show('info', 'Cleared', 'Input and output cleared');
}

function loadExample() {
    const example = `{
  name: 'John Doe',
  age: 30,
  city: 'New York'
  hobbies: ['reading', 'coding', 'gaming',]
  isActive: true,
  address: {
    street: "123 Main St"
    zipCode: 10001
  }
}`;
    document.getElementById('input').value = example;
    processInput();
    toastManager.show('info', 'Example Loaded', 'Malformed JSON example loaded for testing');
}

function copyOutput() {
    if (currentOutput) {
        navigator.clipboard.writeText(currentOutput).then(() => {
            toastManager.show('success', 'Copied!', 'Fixed JSON copied to clipboard');
        }).catch(() => {
            toastManager.show('error', 'Copy Failed', 'Could not copy to clipboard');
        });
    } else {
        toastManager.show('warning', 'Nothing to Copy', 'No output available to copy');
    }
}

function downloadOutput() {
    if (currentOutput) {
        const blob = new Blob([currentOutput], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'fixed-json.json';
        a.click();
        URL.revokeObjectURL(url);
        toastManager.show('success', 'Downloaded', 'Fixed JSON file downloaded');
    } else {
        toastManager.show('warning', 'Nothing to Download', 'No output available to download');
    }
}

function validateOutput() {
    if (!currentOutput) {
        toastManager.show('warning', 'Nothing to Validate', 'No output available to validate');
        return;
    }
    
    try {
        JSON.parse(currentOutput);
        toastManager.show('success', 'Valid JSON!', 'Your JSON is syntactically correct');
    } catch (error) {
        toastManager.show('error', 'Invalid JSON', error.message);
    }
}

function formatOutput() {
    if (!currentOutput) {
        toastManager.show('warning', 'Nothing to Format', 'No output available to format');
        return;
    }
    
    try {
        const parsed = JSON.parse(currentOutput);
        const formatted = JSON.stringify(parsed, null, 2);
        document.getElementById('output').innerHTML = highlightJSON(formatted);
        toastManager.show('success', 'Formatted', 'JSON formatted with proper indentation');
    } catch (error) {
        toastManager.show('error', 'Format Failed', 'Cannot format invalid JSON: ' + error.message);
    }
}

// Enhanced auto-process with debouncing
document.getElementById('input').addEventListener('input', () => {
    clearTimeout(refreshTimeout);
    refreshTimeout = setTimeout(processInput, 300); // 300ms debounce
});

// Load example on page load
window.addEventListener('load', () => {
    setTimeout(() => {
        loadExample();
        toastManager.show('info', 'Welcome!', 'JSON Object Fixer is ready. Edit the example or paste your own malformed JSON.');
    }, 500);
});
    </script>
</body>
</html>